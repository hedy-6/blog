# 内存与垃圾回收机制

## 内存管理

### 参考资料

[MDN-内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)

### 内存生命周期

1. 分配所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放/归还

但在 Javascript 等高级语言中，1、3 部分是隐含的。如：Javascript 在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。

### 垃圾回收 “GC” -- Garbage Collection

垃圾回收是指在计算机编程中，查找和删除那些不再被其他对象引用的对象的处理过程。即删除任何其他对象未使用的对象的过程。

#### 引用计数 ---- 对象有没有其他对象引用到它

这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

```
var o = {
  a: {
    b:2
  }
};
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集

var o2 = o; // o2变量是第二个对“这个对象”的引用
o = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有
var oa = o2.a; // 引用“这个对象”的a属性
               // 现在，“这个对象”有两个引用了，一个是o2，一个是oa
o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
           // 但是它的属性a的对象还在被oa引用，所以还不能回收
oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
```

> 限制：无法处理循环引用的事例。

```
// 两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
```

#### 标记-清除算法 ---- 对象是否可以获得

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。它假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。

从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

> 限制: 那些无法从根对象查询到的对象都将被清除
